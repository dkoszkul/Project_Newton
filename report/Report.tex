\documentclass[12pt]{article}

\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{amsmath} % Required for some math elements 
\usepackage{float}
\usepackage{amssymb}
%pakiety wspomagaj?ce i poprawiaj?ce sk?adanie tabel
\usepackage{supertabular}
\usepackage{array}
\usepackage{tabularx}
\usepackage{hhline}
\usepackage{graphicx} 
\usepackage{wrapfig}


\setlength\parindent{0pt} % Removes all indentation from paragraphs

\title{Newton's method} % Title

\author{Dominik \textsc{Koszkul} \\ Micha\l\ \textsc{Oleszczyk}} % Author name

\usepackage{geometry}

\newgeometry{tmargin=2cm, bmargin=2cm, lmargin=2cm, rmargin=2cm}

\begin{document}

\maketitle % Insert the title, author and date

\section{Introduce}

\subsection{Formulating optimization problem}
Problem, which needs to be solved, is to find minimum point in set of non-linear, multidimensional function. If function has more than one minimum, algorithm is looking for the nearest local minimum from the initial point. In this project, method to find these special points is \textit{Newton's method}. This algorithm allows to find local minimum points, but this particular method can be optimized by using other algorithm to find optimal step, which is used in the main optimization program. Thanks to this, whole algorithm can find the solution in a faster way. The objective function is presented in the following way
\begin{equation}
\min\limits_{x \epsilon \mathbb{R}^n} f(x) ,
\end{equation}
where $n \leqslant 5$. Newton's method is a gradient method without constraints. This means that minimum point is searched in $\mathbb{R}^n$.


\subsection{Newton's method}
Newton's method is a local optimization type algorithm. The algorithm is presented in the following steps:
\begin{enumerate}
\item compute $f(x^i)$ and gradient $\triangledown f(x^i)$,
\item compute direction $d^i=-H^{-1} \triangledown f(x^i)$,
\item compute step length in selected direction (use method which counts minimum in selected direction),
\item check stop criteria (if any criteria are fulfilled then stop and show results),
\item reply all from step 1 with new counted point $x^{i+1}$.
\end{enumerate}

 To implement the method, stop criteria should be also known. In this case we have three main stop criteria for Newton's method and one additional that ensures that program stops computing after exceeding maximum iterations number.

\subsubsection{Stop criteria}
\begin{enumerate}%[label=\arabic*.]
\item $ <grad f(x^i) \cdot grad f(x^i)> \leqslant \varepsilon_1 $ \\
Scalar product of the squared gradient of the function in point $x^i$ should be less or equal to $\varepsilon_1 $,
\item $ ||x^i-x^{i-1}|| \leqslant \varepsilon_2 $ \\
Euclidean norm of the distance between $x^i$ and $x^{i-1}$ points should be less or equal to $\varepsilon_2 $,
\item $ |f(x^i)-f(x^{i-1})| \leqslant \varepsilon_3 $ \\
Difference between values of the function in $x^i$ and $x^{i-1}$ should be less or equal to $\varepsilon_3 $,
\item maximum number of iterations.
\end{enumerate}  
If one from these four criteria is satisfied program stops computing and presents results. 

\subsubsection{Convergence}
Newton's method has a quadratic convergence - convergence rank equals two. This means that, if assumptions are fulfilled, the error decreases in a quadratic way along with the iteration number. In fact the convergence not always is. When the starting point is too far from minimum point the method may be divergent.

\subsubsection{Method constraints}
\textbf{Minimum in selected direction method} \\
Pure Newton's method after computing the direction has set step length which is equal to $1.0$. When the starting point is far from the local minimum the method will have huge amount of iterations and this is main reason of long computing time. In our implementation we used method, which can find the best step length in current iteration. This algorithm is \textit{bisection method with Goldstein test}. We chose this algorithm because in our program we have to compute the gradient and this method also uses the gradient to compute step length. Moreover this is one of the best method for Newton's algorithm. We can also set precision and thank to this manipulate speed of whole program.
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.9]{images/goldstein.png}
\caption{Goldstein test example \cite{mathematics}}
\label{goldstein}
\end{center}		
\end{figure}
Before starting algorithm we have to set a acceptable range $[\tau_l, \tau_r]$ and test coefficient $\beta$. For correct work of the algorithm it is crucial to find proper acceptable range. If it is too small whole algorithm will be computing very slowly due to small step in every iteration. Otherwise if the range is too wide, the method can set to big step and pass the minimum point every time. These values can be set by user before starting computations. \textit{Bisection method with Goldstein test} is represented in the following steps:
\begin{enumerate}
\item compute direction derivative and step coefficient $\tau_r > 0$,
\item designate $\tau=\frac{1}{2}(\tau_l+\tau_r)$ and compute $f(x^i+\tau d)$, where d -- selected direction,
\item if $f(x^i+\tau d)<f(x^i)+(1-\beta)p\tau$ then $\tau_l \rightarrow \tau$,
\item if $f(x^i+\tau d)>f(x^i)+\beta p\tau$ then $\tau_r \rightarrow \tau$ and comeback to second step
\item if third and forth step are not fulfilled stop computing
\end{enumerate}
In our implementation we decided that maximum iteration number in this algorithm will be $10$. This constraint is sufficient and allows to find optimal step in each Newton's method iteration.

\section{General information about the program}
The program was written in \textit{Matlab} environment. We use this program because we know its capabilities very well. Thanks to using \textit{Matlab} we do not need use any external libraries to parse an input (function formula) or plot function / particular steps. To handle any input formula we used internal library, which is integrated with \textit{Matlab} and can find predefined symbols in function -- \textit{symbolic math toolbox}. To design and create graphic user interface we used \textit{GUIDE} library, which is also delivered with \textit{Matlab}.
\section{Rules for setting initial data}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.3]{images/program.png}
\caption{GUI of our program}
\label{program}
\end{center}		
\end{figure}


\vspace{3cm}

\section{Examples}
\subsection{Function with four local minima}
Function equation:
\begin{equation}
y=x_1^4+x_2^4-0.62x_1^2-0.62x_2^2
\end{equation}

Function figures:
	\begin{figure}[H]
		\includegraphics[width=12cm]{four_3d.jpg}
		\caption{Analyzed function 3D view.}
	\end{figure}
	\begin{figure}[H]
			\includegraphics[width=12cm]{four_cont.jpg}
		\caption{Analyzed function contour view.}
	\end{figure}	

	\begin{table}[H]
		Results: \\ \\
		\begin{tabularx}{\textwidth}{c|X|c|c|c|c|}
			iteration & point coordinates & function value & $C_1$ value & $C_2$ value & $C_3$ value\\
			\hline
			0 & $1, 1$ & $0.76$ & $0.132$ & - & - \\
			\hline					
			1 & $0.743, 0.743$ & $-0.0743$ & $0.132$ & $0.363$ & $0.834$ \\ 
			\hline 
			2 & $0.61, 0.61$ & $-0.185$ & $0.0358$ & $0.189$ & $0.11$ \\ 
			\hline
			3 & $5.63\cdot10^{-1}, 5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ & $4.36\cdot10^{-3}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ 
			\hline
			4 & $5.63\cdot10^{-1}, 5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ &
			$7.35\cdot10^{-5}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ \hline
		\end{tabularx}	
	\end{table}		
	\begin{table}[H]
		\begin{tabularx}{\textwidth}{c|X|c|c|c|c|}
			iteration & point coordinates & function value & $C_1$ value & $C_2$ value & $C_3$ value\\
			\hline	
			0 & $-1, 1$ & $0.76$ & $0.132$ & - & - \\
			\hline					
			1 & $-0.743, 0.743$ & $-0.0743$ & $0.132$ & $0.363$ & $0.834$ \\ 
			\hline 
			2 & $-0.61, 0.61$ & $-0.185$ & $0.0358$ & $0.189$ & $0.11$ \\ 
			\hline
			3 & $-5.63\cdot10^{-1}, 5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ & $4.36\cdot10^{-3}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ 
			\hline
			4 & $-5.63\cdot10^{-1}, 5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ &
			$7.35\cdot10^{-5}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ \hline
		\end{tabularx}		 
	\end{table}
	\begin{table}[H]
		\begin{tabularx}{\textwidth}{c|X|c|c|c|c|}
			iteration & point coordinates & function value & $C_1$ value & $C_2$ value & $C_3$ value\\
			\hline	
			0 & $-1, -1$ & $0.76$ & $0.132$ & - & - \\
			\hline					
			1 & $-0.743, -0.743$ & $-0.0743$ & $0.132$ & $0.363$ & $0.834$ \\ 
			\hline 
			2 & $-0.61, -0.61$ & $-0.185$ & $0.0358$ & $0.189$ & $0.11$ \\ 
			\hline
			3 & $-5.63\cdot10^{-1}, -5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ & $4.36\cdot10^{-3}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ 
			\hline
			4 & $-5.63\cdot10^{-1}, -5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ &
			$7.35\cdot10^{-5}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ \hline
		\end{tabularx}		 
	\end{table}
	\begin{table}[H]
		\begin{tabularx}{\textwidth}{c|X|c|c|c|c|}
			iteration & point coordinates & function value & $C_1$ value & $C_2$ value & $C_3$ value\\
			\hline	
			0 & $1, -1$ & $0.76$ & $0.132$ & - & - \\
			\hline					
			1 & $0.743, -0.743$ & $-0.0743$ & $0.132$ & $0.363$ & $0.834$ \\ 
			\hline 
			2 & $0.61, -0.61$ & $-0.185$ & $0.0358$ & $0.189$ & $0.11$ \\ 
			\hline
			3 & $5.63\cdot10^{-1}, -5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ & $4.36\cdot10^{-3}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ 
			\hline
			4 & $5.63\cdot10^{-1}, -5.63\cdot10^{-1}$  & $-1.92\cdot10^{-1}$ &
			$7.35\cdot10^{-5}$ & $6.6\cdot10^{-2}$ & $7.5\cdot10^{-3}$ \\ \hline
		\end{tabularx}		 
	\end{table}
	
	\begin{figure}[H]
		\includegraphics[width=16cm]{four_results.png}
		\caption{Location of four minima.}
	\end{figure}
	
\begin{thebibliography}{99}
\bibitem{mathematics} http://math.stackexchange.com/questions/873467/goldstein-test-in-nonlinear-programming
\end{thebibliography}
	
	
\end{document}